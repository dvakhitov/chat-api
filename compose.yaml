version: "3.8"

services:
  # Nginx as load balancer
  nginx:
    image: nginx:1.27.3-alpine
    # container_name: nginx  # Убрали, чтобы не мешать масштабированию
    depends_on:
      - app
    ports:
      - "${NGINX_PORT:-80}:80"  # Можно оставить дефолт 80, если NGINX_PORT не задан
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    networks:
      - symfony_net

    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost" ]
      interval: 30s
      timeout: 5s
      retries: 3

  # Symfony application
  app:
    build:
      context: ./symfony
      dockerfile: Dockerfile
    # container_name: app
    working_dir: /var/www/symfony
    volumes:
      - ./symfony:/var/www/symfony
      # При необходимости монтировать .env (но лучше secrets/конфиг)
      # - ./symfony/.env:/var/www/symfony/.env:ro
    environment:
      APP_ENV: "${APP_ENV:-prod}"
      # DB_PASSWORD и APP_SECRET подтягиваем через entrypoint-скрипт или аналог
      # Здесь пример, как мы используем уже сконструированный URL:
      DATABASE_URL: "postgresql://symfony:${DB_PASSWORD}@db-primary:5432/symfony"
      APP_SECRET: "${APP_SECRET}"
    depends_on:
      - db-primary
    networks:
      - symfony_net
    deploy:
      mode: replicated
      replicas: 3  # Three replicas of the Symfony app
      restart_policy:
        condition: on-failure
      resources:
        limits:
          cpus: "1.0"
          memory: 1024M
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost/healthz" ]
      interval: 30s
      timeout: 10s
      retries: 3

  # Primary PostgreSQL database
  db-primary:
    image: postgres:17.2
    # container_name: db_primary
    environment:
      POSTGRES_USER: symfony
      # Вместо POSTGRES_PASSWORD используем POSTGRES_PASSWORD_FILE, чтобы читать из секрет-файла
      POSTGRES_PASSWORD_FILE: "/run/secrets/db_password"
      POSTGRES_DB: symfony
    volumes:
      - db_primary_data:/var/lib/postgresql/data
    networks:
      - symfony_net
    deploy:
      mode: replicated
      replicas: 1
      restart_policy:
        condition: on-failure
      resources:
        limits:
          cpus: "0.50"
          memory: 512M
    healthcheck:
      test: [ "CMD", "pg_isready", "-U", "symfony" ]
      interval: 30s
      timeout: 5s
      retries: 5

  # Replica PostgreSQL database
  db-replica:
    image: postgres:17.2
    # container_name: db_replica
    depends_on:
      - db-primary
    command: >
      postgres -c 'wal_level=logical' -c 'hot_standby=on'
    environment:
      POSTGRES_USER: symfony
      POSTGRES_PASSWORD_FILE: "/run/secrets/db_password"
    volumes:
      - db_replica_data:/var/lib/postgresql/data
    networks:
      - symfony_net
    deploy:
      mode: replicated
      replicas: 1
      restart_policy:
        condition: on-failure
      resources:
        limits:
          cpus: "0.50"
          memory: 512M
    healthcheck:
      test: [ "CMD", "pg_isready", "-U", "symfony" ]
      interval: 30s
      timeout: 5s
      retries: 5

  # Redis for caching
  redis:
    image: redis:7.4
    # container_name: redis
    # Оставим порты, если нужно подключаться извне для теста:
    ports:
      - "6378:6379"
    command: [ "redis-server", "--save", "60", "1", "--loglevel", "warning" ]
    volumes:
      - redis-data:/data
    networks:
      - symfony_net
    deploy:
      mode: replicated
      replicas: 1
      restart_policy:
        condition: on-failure
      resources:
        limits:
          cpus: "0.25"
          memory: 256M
    healthcheck:
      test: [ "CMD", "redis-cli", "ping" ]
      interval: 30s
      timeout: 5s
      retries: 3

networks:
  symfony_net:
    # В Swarm будет overlay, в обычном Compose – bridge
    driver: bridge

volumes:
  db_primary_data:
  db_replica_data:
  redis-data:


  app_secret:
    external: true
